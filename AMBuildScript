# AMBuildScript
import os

# 1. 检测编译器 (保持 x86 目标，千万不要改)
cxx = builder.DetectCxx(target_arch=builder.options.targets)
library = cxx.Library('momsurffix_ext.ext')

# 2. 源文件
library.sources += [ 'momsurffix_ext.cpp', 'simple_detour.cpp' ]

# 3. 获取路径参数
sm_path = builder.options.sm_path
mms_path = builder.options.mms_path
hl2sdk_path = builder.options.hl2sdk_path

# 4. 头文件包含路径
library.compiler.includes += [
    builder.sourcePath,
    os.path.join(sm_path, 'public'),
    os.path.join(sm_path, 'public/extensions'),
    os.path.join(sm_path, 'public/sourcepawn'),
    os.path.join(sm_path, 'sourcepawn/include'),
    os.path.join(sm_path, 'public/amtl'),
    os.path.join(sm_path, 'public/amtl/amtl'),
    os.path.join(sm_path, 'third_party/amtl'),
    os.path.join(sm_path, 'third_party/amtl/amtl'),
    os.path.join(mms_path, 'core'),
    os.path.join(mms_path, 'core/sourcehook'),
    os.path.join(hl2sdk_path, 'public'),
    os.path.join(hl2sdk_path, 'public/engine'),
    os.path.join(hl2sdk_path, 'public/mathlib'),
    os.path.join(hl2sdk_path, 'public/vstdlib'),
    os.path.join(hl2sdk_path, 'public/tier0'),
    os.path.join(hl2sdk_path, 'public/tier1'),
    os.path.join(hl2sdk_path, 'game/shared'),
    os.path.join(hl2sdk_path, 'common'),
]

# 5. 核心宏定义
library.compiler.defines += [
    'SOURCEMOD_BUILD',
    'HAVE_STRING_H',
    'SE_EPISODEONE',
    'COMPILER_GCC',
    '_LINUX',
    'LINUX',
    'POSIX',
    '_POSIX',
    '_NATIVE_WCHAR_T_DEFINED',
    'register=', 
    'GNUC', 
]

# 6. 编译器标志 (GCC 9+ 兼容性)
library.compiler.cxxflags += [
    '-std=c++17',
    '-fno-threadsafe-statics',
    '-fvisibility=hidden',
    '-fshort-wchar',
    '-fms-extensions',
    '-msse',
    '-msse2',
    '-Wno-deprecated-declarations',
    '-Wno-macro-redefined',
    '-Wno-register',
    '-Wno-invalid-offsetof',
]

# 7. 链接标志
library.compiler.linkflags += ['-lm', '-ldl']

# =============================================================================
# 【核心修复】链接 CS:GO Legacy (32-bit) 必须的 tier0 和 vstdlib
# 解决 undefined symbol: Warning / ConMsg / g_pMemAlloc 问题
# =============================================================================

libdir = os.path.join(hl2sdk_path, 'lib', 'linux')

# 优先寻找 _srv.so (服务端专用版)，如果没有则寻找普通 .so
lib_tier0 = os.path.join(libdir, 'libtier0_srv.so')
lib_vstdlib = os.path.join(libdir, 'libvstdlib_srv.so')

if not os.path.exists(lib_tier0):
    lib_tier0 = os.path.join(libdir, 'libtier0.so')
    
if not os.path.exists(lib_vstdlib):
    lib_vstdlib = os.path.join(libdir, 'libvstdlib.so')

# Postlink 顺序非常关键：
# 1. 静态库 (.a) 必须在前
# 2. 动态库 (.so) 必须在后
# 这样链接器才能在 .so 中找到 .a 缺失的符号
library.compiler.postlink += [
    os.path.join(libdir, 'tier1_i486.a'),
    os.path.join(libdir, 'mathlib_i486.a'),
    os.path.join(libdir, 'interfaces_i486.a'),
    lib_tier0,
    lib_vstdlib,
]

builder.Add(library)
